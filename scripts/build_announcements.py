#!/usr/bin/env python3
from __future__ import annotations

import argparse
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Any

from pipeline_utils import VERSION, read_json, utc_now_iso, write_json


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Build announcements.json for the timetable app.")
    parser.add_argument("--out", required=True, help="Output directory where announcements.json is written.")
    parser.add_argument(
        "--announcements",
        default="config/announcements.json",
        help="Optional manual announcements JSON config (default: config/announcements.json).",
    )
    parser.add_argument(
        "--status",
        default="dist/.scrape-status.json",
        help="Scrape status file generated by scripts/scrape.py (default: dist/.scrape-status.json).",
    )
    return parser.parse_args()


def _load_manual_items(path: Path) -> list[dict[str, Any]]:
    if not path.exists():
        return []
    payload = read_json(path)
    if isinstance(payload, dict) and isinstance(payload.get("items"), list):
        return [item for item in payload["items"] if isinstance(item, dict)]
    raise ValueError(f"{path}: expected an object with an 'items' array.")


def _load_status(path: Path) -> dict[str, Any]:
    if not path.exists():
        return {}
    payload = read_json(path)
    if isinstance(payload, dict):
        return payload
    raise ValueError(f"{path}: expected a JSON object.")


def _auto_failure_announcement(status: dict[str, Any]) -> dict[str, Any] | None:
    failures = status.get("failures")
    if not isinstance(failures, list) or not failures:
        return None

    generated_at = status.get("generatedAt")
    if isinstance(generated_at, str):
        try:
            date_part = generated_at.split("T", 1)[0]
            run_date = datetime.fromisoformat(f"{date_part}T00:00:00+00:00")
        except ValueError:
            run_date = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)
    else:
        run_date = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)

    ends_at = run_date + timedelta(days=2)
    return {
        "id": f"refresh-delayed-{run_date.date().isoformat()}",
        "title": "Timetable refresh delayed",
        "message": (
            f"Latest refresh failed for {len(failures)} source(s). "
            "Showing the most recent successful timetable where available."
        ),
        "severity": "warning",
        "symbolName": "exclamationmark.triangle.fill",
        "startsAt": run_date.isoformat().replace("+00:00", "Z"),
        "endsAt": ends_at.isoformat().replace("+00:00", "Z"),
    }


def _dedupe_items(items: list[dict[str, Any]]) -> list[dict[str, Any]]:
    deduped: list[dict[str, Any]] = []
    seen_ids: set[str] = set()
    for item in items:
        item_id = item.get("id")
        if not isinstance(item_id, str) or not item_id.strip():
            continue
        if item_id in seen_ids:
            continue
        seen_ids.add(item_id)
        deduped.append(item)
    return deduped


def main() -> int:
    args = _parse_args()
    out_dir = Path(args.out)
    out_dir.mkdir(parents=True, exist_ok=True)

    manual_items = _load_manual_items(Path(args.announcements))
    status = _load_status(Path(args.status))
    auto_item = _auto_failure_announcement(status)

    all_items = list(manual_items)
    if auto_item:
        all_items.append(auto_item)
    all_items = _dedupe_items(all_items)

    payload = {
        "version": VERSION,
        "generatedAt": utc_now_iso(),
        "items": all_items,
    }
    write_json(out_dir / "announcements.json", payload)
    print(f"Wrote {len(all_items)} announcements.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
